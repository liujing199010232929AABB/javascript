<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>P19_构造函数拓展和寄生构造函数模式</title>
	</head>
	<body>
		<script type="text/javascript">
			// 1.构造函数拓展模式
			// 2.寄生构造函数模式
			// 3.稳妥构造函数模式
			function Person(name,age){
				
				this.name = name;
				this.age = age;
				this.sayName = sayName;
			}
			// 定义多个全局函数,严重污染全局空间
			function sayName(){
				console.log(this.name);
			}
			var man = new Person('mjj',18);
			var woman = new Person('alex',38);
            console.log(man.sayName === woman.sayName);
            
            // 2.寄生构造函数模式
			// 工厂模式和构造函数模式
			// 创建一个函数,函数体内部实例化一个对象,并且将对象返回,在外部的使用使用new来实例化对象
			// 问题: 1.定义了相同的方法,浪费内存空间
			// 2.instanceof运算符和prototype属性都没有意义.
			
			// 该模式尽量避免使用
			function Person(name,age){
				var o = new Object();
				o.name = name;
				o.age = age;
				o.sayName = function(){
					console.log(this.name);
				}
				return o;
			}
			var man = new Person('mjj',18);
			var woman = new Person('alex',38);
			console.log(man.sayName === woman.sayName);
			console.log(man.__proto__ === Person.prototype);//false
			console.log(man instanceof Person);


		</script>
	</body>
</html>
